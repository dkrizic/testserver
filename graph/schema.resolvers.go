package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"

	"github.com/dkrizic/testserver/graph/model"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

// Users is the resolver for the users field.
func (r *groupResolver) Users(ctx context.Context, obj *model.Group, skip *int, limit *int) ([]*model.User, error) {
	slog.Info("Users(forGroup)", "id", obj.ID, "skip", skip, "limit", limit)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	span.SetAttributes(attribute.String("id", obj.ID))
	query := "SELECT user.id,user.email FROM user,user_group where user_group.user_id = user.id and user_group.group_id = ? limit ?,?"
	span.SetAttributes(
		attribute.String("db.query.text", query),
		attribute.String("db.parameter.id", obj.ID))
	result, err := r.dB.Query(query, obj.ID, skip, limit)
	if err != nil {
		return nil, err
	}
	defer result.Close()

	users := []*model.User{}
	for result.Next() {
		var user model.User
		err := result.Scan(&user.ID, &user.Email)
		if err != nil {
			return nil, err
		}
		users = append(users, &user)
	}
	return users, nil
}

// Asset is the resolver for the asset field.
func (r *queryResolver) Asset(ctx context.Context, id *string, skip *int, limit *int) ([]*model.Asset, error) {
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	if id != nil {
		span.SetAttributes(attribute.String("id", *id))
	}
	slog.Info("Asset", "id", id, "skip", skip, "limit", limit)
	var result *sql.Rows
	var err error
	if id != nil {
		query := "SELECT id,name FROM asset WHERE id = ?"
		span.SetAttributes(
			attribute.String("db.query.text", query),
			attribute.String("db.query.parameter.id", *id))
		result, err = r.dB.Query(query, *id)
		if err != nil {
			return nil, err
		}
	} else {
		query := "SELECT id,name FROM asset LIMIT ?,?"
		span.SetAttributes(attribute.String("db.query.text", query))
		result, err = r.dB.Query(query, skip, limit)
		if err != nil {
			return nil, err
		}
	}
	defer result.Close()

	assets := []*model.Asset{}
	for result.Next() {
		var asset model.Asset
		err := result.Scan(&asset.ID, &asset.Name)
		if err != nil {
			return nil, err
		}
		assets = append(assets, &asset)
	}
	span.SetAttributes(attribute.Int("assets.count", len(assets)))
	return assets, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *string, skip *int, limit *int) ([]*model.User, error) {
	slog.Info("User", "id", id, "skip", skip, "limit", limit)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	if id != nil {
		span.SetAttributes(attribute.String("id", *id))
	}
	var result *sql.Rows
	var err error
	if id != nil {
		query := "SELECT id,email FROM user WHERE id = ?"
		span.SetAttributes(
			attribute.String("db.query.text", query),
			attribute.String("db.query.parameter.id", *id))
		result, err = r.dB.Query(query, *id)
		if err != nil {
			return nil, err
		}
	} else {
		query := "SELECT id,email FROM user LIMIT ?,?"
		span.SetAttributes(attribute.String("db.query.text", query))
		result, err = r.dB.Query(query, *skip, *limit)
		if err != nil {
			return nil, err
		}
	}
	defer result.Close()

	users := []*model.User{}
	for result.Next() {
		var user model.User
		err := result.Scan(&user.ID, &user.Email)
		if err != nil {
			return nil, err
		}
		users = append(users, &user)
	}
	return users, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id *string, skip *int, limit *int) ([]*model.Group, error) {
	slog.Info("Group", "id", id, "skip", skip, "limit", limit)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	if id != nil {
		span.SetAttributes(attribute.String("id", *id))
	}
	var result *sql.Rows
	var err error
	if id != nil {
		query := "SELECT id,name FROM group WHERE id = ?"
		span.SetAttributes(
			attribute.String("db.query.text", query),
			attribute.String("db.query.parameter.id", *id))
		result, err = r.dB.Query(query, *id)
		if err != nil {
			return nil, err
		}
	} else {
		query := "SELECT id,name FROM `group` LIMIT ?,?"
		span.SetAttributes(attribute.String("db.query.text", query))
		result, err = r.dB.Query(query, *skip, *limit)
		if err != nil {
			return nil, err
		}
	}
	defer result.Close()

	groups := []*model.Group{}
	for result.Next() {
		var group model.Group
		err := result.Scan(&group.ID, &group.Name)
		if err != nil {
			return nil, err
		}
		groups = append(groups, &group)
	}
	return groups, nil
}

// Identity is the resolver for the identity field.
func (r *queryResolver) Identity(ctx context.Context, skip *int, limit *int) ([]model.Identity, error) {
	slog.InfoContext(ctx, "Identity", "skip", skip, "limit", limit)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	query := "SELECT id,email FROM user LIMIT ?,?"
	span.SetAttributes(attribute.String("db.query.text", query))

	result, err := r.dB.Query(query, *skip, *limit)
	if err != nil {
		return nil, err
	}
	defer result.Close()

	identities := []model.Identity{}
	for result.Next() {
		var user model.User
		err := result.Scan(&user.ID, &user.Email)
		if err != nil {
			return nil, err
		}
		identities = append(identities, user)
	}

	query = "SELECT id,name FROM `group` LIMIT ?,?"
	span.SetAttributes(attribute.String("db.query.text", query))
	result, err = r.dB.Query(query, *skip, *limit)
	if err != nil {
		return nil, err
	}
	defer result.Close()

	for result.Next() {
		var group model.Group
		err := result.Scan(&group.ID, &group.Name)
		if err != nil {
			return nil, err
		}
		identities = append(identities, group)
	}

	return identities, nil
}

// TagCategory is the resolver for the tagCategory field.
func (r *queryResolver) TagCategory(ctx context.Context, id *string) (model.TagCategory, error) {
	type MergedTagCategory struct {
		ID            string
		Name          string
		Discriminator string
		Parent        string
		Format        string
		Open          bool
	}

	slog.InfoContext(ctx, "TagCategory", "id", id)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"))
	if id != nil {
		span.SetAttributes(attribute.String("id", *id))
	}

	query := "SELECT id,name FROM tagcategory WHERE id = ?"
	span.SetAttributes(attribute.String("db.query.text", query))
	result, err := r.dB.Query(query, *id)
	if err != nil {
		return model.StaticTagCategory{}, err
	}
	defer result.Close()

	var mergedTagCategory MergedTagCategory
	for result.Next() {
		err := result.Scan(&mergedTagCategory.ID, &mergedTagCategory.Name, &mergedTagCategory.Discriminator, &mergedTagCategory.Parent, &mergedTagCategory.Format, &mergedTagCategory.Open)
		if err != nil {
			return nil, err
		}
	}

	switch mergedTagCategory.Discriminator {
	case "static":
		return model.StaticTagCategory{
			ID:     mergedTagCategory.ID,
			Name:   mergedTagCategory.Name,
			IsOpen: mergedTagCategory.Open,
		}, nil
	case "dynamic":
		return model.DynamicTagCategory{
			ID:     mergedTagCategory.ID,
			Name:   mergedTagCategory.Name,
			Format: mergedTagCategory.Format,
		}, nil
	default:
		return nil, fmt.Errorf("unknown tag category discriminator: %s", mergedTagCategory.Discriminator)
	}
}

// TagCategories is the resolver for the tagCategories field.
func (r *queryResolver) TagCategories(ctx context.Context, skip *int, limit *int) ([]model.TagCategory, error) {
	type MergedTagCategory struct {
		ID            string
		Name          string
		Discriminator string
		Parent        *string
		Format        *string
		Open          bool
	}

	slog.InfoContext(ctx, "TagCategories", "skip", skip, "limit", limit)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	query := "SELECT id,name,discriminator,parent,format,open FROM tagcategory LIMIT ?,?"
	span.SetAttributes(attribute.String("db.query.text", query))
	result, err := r.dB.Query(query, *skip, *limit)
	if err != nil {
		return nil, err
	}
	defer result.Close()

	tagCategories := []model.TagCategory{}
	for result.Next() {
		var mergedTagCategory MergedTagCategory
		err := result.Scan(&mergedTagCategory.ID, &mergedTagCategory.Name, &mergedTagCategory.Discriminator, &mergedTagCategory.Parent, &mergedTagCategory.Format, &mergedTagCategory.Open)
		if err != nil {
			return nil, err
		}

		switch mergedTagCategory.Discriminator {
		case "static":
			tagCategories = append(tagCategories, model.StaticTagCategory{
				ID:     mergedTagCategory.ID,
				Name:   mergedTagCategory.Name,
				IsOpen: mergedTagCategory.Open,
			})
		case "dynamic":
			tagCategories = append(tagCategories, model.DynamicTagCategory{
				ID:     mergedTagCategory.ID,
				Name:   mergedTagCategory.Name,
				Format: *mergedTagCategory.Format,
			})
		default:
			return nil, fmt.Errorf("unknown tag category discriminator: %s", mergedTagCategory.Discriminator)
		}
	}

	return tagCategories, nil
}

// Groups is the resolver for the groups field.
func (r *userResolver) Groups(ctx context.Context, obj *model.User, skip *int, limit *int) ([]*model.Group, error) {
	slog.Info("Groups(forUser)", "id", obj.ID, "skip", skip, "limit", limit)
	span := trace.SpanFromContext(ctx)
	span.SetAttributes(
		attribute.String("db.system", "mysql"),
		attribute.String("db.operation.name", "select"),
		attribute.Int("skip", *skip),
		attribute.Int("limit", *limit))
	span.SetAttributes(attribute.String("id", obj.ID))
	query := "SELECT `group`.id,`group`.name FROM `group`,user_group where user_group.group_id = `group`.id and user_group.user_id = ? limit ?,?"
	span.SetAttributes(
		attribute.String("db.query.text", query),
		attribute.String("db.parameter.id", obj.ID))
	result, err := r.dB.Query(query, obj.ID, skip, limit)
	if err != nil {
		return nil, err
	}
	defer result.Close()

	groups := []*model.Group{}
	for result.Next() {
		var group model.Group
		err := result.Scan(&group.ID, &group.Name)
		if err != nil {
			return nil, err
		}
		groups = append(groups, &group)
	}
	return groups, nil
}

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type groupResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type mutationResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
